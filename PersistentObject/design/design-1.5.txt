eZ component: PersistentObject, Design, 1.5
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:Author:   Tobias Schlitt
:Revision: $Rev$
:Date:     $Date$
:Status:   Draft

.. contents::

=====
Scope
=====

The scope of this document is to describe the proposed enhancements for the
PersistentObject component version 1.5.

The general goal for this version is to implement various features
described by these issues in our issue tracker:

- #11831: isRelated() Method.
- #12473: Identity map for PersistentObject.
- #13073: Sub-select support for PersistentObject.
- #13074: Fetching related objects through joins.
- #13170: Support for custom relation implementations.

Each of the issues and their proposed solutions are explained in a separate
chapter in this document. Some issues relate to each other, which is also
explained in the issue descriptions. The requirements for each of the
enhancements can be found in the corresponding requirements document.

=================================
Identity map for PersistentObject
=================================

The Identity Map pattern is described by Martin Fowler in his book Patterns of
Enterprise Application Architecture. The purpose of this pattern is to avoid
that 2 or more objects representing the same database row reside in memory. The
problems here are:

a) Duplicate memory consumption
b) Potential inconsistencies between different copies of the same object.

To avoid this, the data manipulation mechanisms must take care of not
delivering duplicate instances of the same data. Beside that, it can cache
certain queries as long as manipulations are reflected properly. The data
manipulation mechanisms in our case are realized in the ezcPersistentSession
and related (internal) handler classes.

------
Design
------

The Identity Map support should be optional to not break BC and keep
flexibility. Therefore, a new class named ezcPersistentIdentityMapSession is
implemented. This extends the current implementation ezcPersistentSession to
make instanceof checks still work. All of the methods will be overwritten and
new handler classes, extending the existing ones will be implemented to reflect
the actual additions. The methods that are not supported by the new class will
be declared private and throw an exception is used externally.

The class design will work as follows:

ezcPersistentIdentitySession
============================

This main class will be used exactly like ezcPersistentSession and realizes the
desired functionality completely transparent to the user. This allows users to
transparently replace the old version and vise versa. The class will moddel a
decorator for the existing ezcPersistentSession.

Functionality
-------------

The constructor of the class receives an ezcPersistentSession instance to
decorate and an object of type ezcPersistentIdentityMap, which realizes the
identity mapping itself. This central point is used as the session cache. All
method calls, that are affected as described in the requirements document, will
utilize this object to grab cached object identities and to reflect their
changes.

ezcPersistentIdentitySession will implement the same methods as
ezcPersistentSession and perform the necessary cache inserts, updates and
lookups around it. The following methods cannot be traced correctly and may
therefore lead to inconsistencies:

- createUpdateQuery()
- updateFromQuery()
- createDeleteQuery()
- deleteFromQuery()

The use of the \*FromQuery() methods will therefore result in a complete purge
of the identity map to ensure consistency.

Interface
---------

load( string $class, mixed $id )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In case the requested object is found in the identity map, it will be returned
from there. Otherwise the decorated persistent session will issue a normal
load() operation and the result will be recorded in the identity map.
loadIfExists() will react the same way.

loadIntoObject( object $object, mixed $id )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In case the given $object already is a loaded instance of an object, an
exception will be thrown. If the desired object with the $id was already
recorded in the identity map, an exception is thrown, too, since the operation
would result in a copy. Otherwise the load is performed as desired and the
resulting object instance is recorded and returned.

find( ezcQuerySelect $query, $class )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ezcPersistentSession->find() is executed. In the resulting array, each object
is checked in the identity map. If an identity is found, it is replaced into
the result. If the identity of the object is not yet knowen, it is recorded.

.. note::
   The $class parameter could be deprecated here by introcuding a decorated
   ezcQuerySelect class for the PersistentObject component. We should still
   keep it for BC reasons.

It is possible to disable the identity caching globally when performing a
find(), using the $refetch option of the identity map. In that case, recorded
indenities will be overwritten by found ones.

.. note::
   This is dangerous, since duplicates can occur in the application. A better
   way is to leave $refetch off and explicitly update the existing instances
   using the update() method.

findIterator( ezcQuerySelect $query, string $class )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To support this method properly, a new class ezcPersistentIdenitiyFindIterator
is introduced. This one decorates the ezcPersistentFindIterator returned by
ezcPersistentSession->findIterator(). The decorating class will take care of
modelling the same behavior as described above with the find() method.

getRelatedObjects( object $object, $relatedClass, $relationName = null )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method checks the relation cache of the identity map first, if a result
set has already been stored for the given relation. If this is the case, the
cached result will be returned.

This behavior can be switched off using the $cacheRelations option of the
identity map. If this option is switched to false, relations will always be
fetched from the database and not be recorded.

Beside that, the option $refetchRelations can be set to true. This way,
relations will be refetched from the database and the fetched result will be
recorded.

Both options do not affect the identity mapping itself. In case the identity of
an object has been recorded, the cached identity will be replaced into the
result set.

getRelatedObject( object $object, $relatedClass, $relationName = null )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Same as above, only for a single object.

save( object $object )
^^^^^^^^^^^^^^^^^^^^^^

Whenever a new object was saved successfully, it is recorded in the identity
map.

saveOrUpdate( object $object )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method reacts the same as save() if the operation was not an update. In
case of an update nothing is to do, since the object is already part of the
identity map.

addRelatedObject( object $sourceObject, object $relatedObject )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If relation caching is globally switched on, the first check this method
performs is to see if another object was previously related to this one and the new
$relatedObject replaces this relation. In this case, the old relation (if
recorded) is removed. After that, the new relation is recorded.

.. note::
   It should be discussed if it is feasible to perform the save() operation
   after a newly established relation automatically here, since otherwise
   inconsistencies might occur with the mapping cache. ezcPersistentSession
   does not do this, to avoid multiple UPDATE queries. Maybe a global switch in
   ezcPersistentSession to activate this overall might be sensible?

delete( object $object )
^^^^^^^^^^^^^^^^^^^^^^^^

This method must remove all references to the object from all mapping caches
before actually deleting the object itself from the DB. This is the most time
consuming work, since multiple isset() calls might be necessary to remove all
identities from the relation cache.

.. note::
   The delete() operation also removes all relations and, if cascading is used,
   also removes related objects. Therefore the operation might even run longer.

Performance should be a major concern when writing this code.

removeRelatedObject( object $sourceObject, object $relatedObject, string $relationName = null )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If relation caching is globally turned on, the relation must be removed from
the cache before it is actually removed from the object / database.

.. note::
   It should be discussed if it is feasible to perform the save() operation
   after a newly established relation automatically here, since otherwise
   inconsistencies might occur with the mapping cache. ezcPersistentSession
   does not do this, to avoid multiple UPDATE queries. Maybe a global switch in
   ezcPersistentSession to activate this overall might be sensible?

ezcPersistentIdenityOptions
===========================

The new ezcPersistentIdentityMap can be configured to switch on and off
certain features. The options are:

$refetch = false;
  Setting this to true will make the identity map indicate that no results have
  been cached, yet. The result is, that the persistent session will re-fetch
  all objects and record them in the identity map. This also affects the
  relation cache ($refetchRelations = true).
$cacheRelations = true;
  Switching this to false makes all relation query be executed and no result
  sets for relations be cached.
$refetchRelations = false;
  This switch allows to switch refetching on for relations. Cached relations
  will be ignored and the persistent session will refetch related objects.
  However, only the relation result sets will be overwritten, the object
  identities will still be fetched from the map, if possible.

ezcPersistentIdentityMap
========================

This class is the internal heart of the identity map enhancement. It handles
all caching and mapping activities globally for a session.

Users shall usually not access the identity map object directly to fetch cached
objects or add new ones. On the other hand, the identity map should be
replaceable to allow more advanced implementations (e.g. involving the Cache
component). Therefore most methods of this class will public, but marked as
proteced via documentation.

Functionality
-------------

The following 2 areas of identity mapping will be handled:

1. The identity mapping itself.

   In this cache, each persistent object that is available in the session is
   recorded once. The mapping is::

        array(
            <class_name> => array(
                <id_value> => <object>,
                <id_value> => <object>,
                <id_value> => <object>,
                // ...
            ),
            // ...
        )

   An object is added to this cache map whenever it is loaded from the database
   (no matter in which way) or if it is stored. Operations which load objects
   from the database commonly check this map after the load occurred. If the
   loaded object already exists in the session, the newly loaded instance is
   discarded again and replaced by the existing one.

2. The relation mapping.

   The getRelatedObject[s]() methods are highly essential and also most
   performance hungry, if related objects need to be fetched for a large number
   of objects. To avoid this being performed multiple times in a request,
   results of calls to these methods should be stored in a dedicated cache.
   Whenever a set of related objects is retrieved, the following data structure
   will be updated::

        array(
            <source_class> => array(
                <source_id> => array(
                    <related_class> => array(
                        <related_id> => <related_object>,
                        <related_id> => <related_object>,
                        <related_id> => <related_object>,
                        // ...
                    ),
                    // ...
                ),
                // ...
            ),
            //...
        )

    Once again the same request is submitted to getRelatedObject[s](), the
    cached results will be returned. Since this behavior can be memory
    consuming if many of the loaded objects are discarded by the user directly
    after being loaded, it is be possible to disable this cache globally. In
    addition, the refreshing of a set of objects will easily be possible, to
    update the cached results on request.

Interface
---------

The following methods will be provided by the map:

- recordObject( object $object )

  Adds a new object to the real identity map. The object will be replaced, if
  it has already been recorded earlier.

- getObject( string $class, mixed $id )

  Returns the object recorded for $class, identified by $id. If such object is
  not available, null is returned.

- resetObjectMap()

  Resets the object map. Attention, dangerous!

- recordRelatedObjects( object $sourceObject, array(object) $relatedObjects )

  Records the set of $relatedObjects to belong to $object. The array may also
  contain objects that have already been recorded. These are then replaced.

- addRelatedObject( object $sourceObject, object $relatedObject )

  Appends a related object to an existing recorded relation. Used in
  ezcPersistentIdentitySession->addRelatedObject(). If the relation is not
  recorded yet, it is not created, but the call is ignored.

- removeRelatedObject( object $sourceObject, object $relatedObject )

  Removes a related object from the relation cache. Used in
  ezcPersistentIdentitySession->removeRelatedObject().

- getRelatedObjects( object $sourceObject, string $class )

  Returns an array of objects of type $class related to $sourceObject. This can
  also be an empty array, if the last lookup in the database resulted in such.
  In case no related objects have been recorded, yet, null is returned.

- resetRelatedObjects( object $sourceObject, string $class = null )

  This method clears the recorded objects of a type $class related to
  $sourceObject. This method should be used to re-initialize the mapping before
  a re-fetch takes place.

- resetRelationMap()

  Resets the relation map. Attention, dangerous!

- reset()

  Calls the 2 methods above.


-----------
Open issues
-----------

- Making the identity map a decorator to ezcPersistentSession would design wise
  be a nicer solution, but also has some flaws:

  - No transparent replacement of current $session objects possible, due to
    instanceof checks. Maybe introduce a common interface (would also allow
    different implementations of ezcPersistentSession in future)?
  
  - It would make sense to allow the identity mapping session to access certain
    protected functionality (creation of queries, execution, ...). This could
    be solved by making the affected methods public and documenting them as
    protected.

- Do we need an option to explicitly reload (load()) an object? refresh() on
  the existing version is more logical.
- loadIfExists() can return null. Should this result be cached or should the
  method try to load again if no object has been loaded successfully, yet?
- The updates to perform in the delete() method can become quite time consuming
  if all caching facilities are switched on.
- A nice idea would be to enable the replacement of ezcPersistentIdentityMap
  with a custom implementation. For example it could make sense to offer a
  PersistentObjectCacheTiein to have the identity map cache objects to disc
  (request by BD).

- The update() method only allows to update 1 specific object right now. This
  results in a lot of select queries, if multiple objects need to be updated.
  We should allow arrays of objects here and update them in a row using <id> IN
  ( ... ).

======================================
Fetching related objects through joins
======================================

Relation management with Persistent Objects is very convenient and powerful.
However, it suffers from one of the common consequences of such methods: the
amount of SQL queries you end up executing.

Since using relations is easy, you will easily end up running dozens or hundreds
of SQL queries, especially when using the templates component::

	{$event->location->name}

Very convenient, but this will run at least one extra query here; if you do this
when listing, let's say events, you will execute one extra query for each event
you display the location for. If you also display the event's responsible name,
it's another query. If you show 10 events, you execute 21 queries, and this is
not acceptable.

------
Design
------

Since ezcPersistentObject allows us to define relations between persistent
classes, we have everything we need to fetch all desired objects in one
operation. To allow the user to limit the fetched objects effectively, the
createFindQuery method will be enhanced to create queries that fetch objects
and their relatives. ::

    ezcQuerySelect createFindQuery( string $class, array $relations = null )

The $relations parameter contains an array structure which represents the
relation tree to fetch. The structure of this array will look as follows::

    array(
        'myLocation' => true,
        'myResponsible' => array(
            'myAddress' => true,
            'myCompany' => true,
        ),
    )

The keys of the array structure represent persistent class names. A key might
either be assigned to the value true or to another array of relatives to fetch.
True means "fetch the desired relatives, but no further ones in this
direction". An array as the value describes to fetch further relatives for the
relative.

In the example above objects of 2 different classes will be fetched for the
source objects originally fetched by the find query: myLocation and
myResponsible. For the objects fetched fore the myResponsible class further
relatives will be fetched in addition: myAddress and myCompany.

The query object returned by the createFindQuery() method already implements
all joins necessary to fetch the desired objects. Beside that, is has aliases
registered for all requested relatives as well as for the source class. The
source class aliases are registered without any prefix, as known from the
original behavior of createFindQuery(). For the relatives, the aliases will be
prefixed by the class hierarchy indicated by the relation array. This allows
the user to define additional WHERE and ORDER BY statements on the SELECT
query.

For example, if the myLocation class defines a persistent attribute $city, an
alias myLocation_city will be available. The myAddress->$zip property will be
available through the alias myRepsonsible_myAddress_zip. The prefixing with all
ascending classes is necessary to avoid conflicts if relations to one class
should be resolved in different places.

The query object returned by createFindQuery() with the additional $relations
parameter will not be an instance of ezcQuerySelect directly, but a decorated
version. This allows the method to annotate the query with the $relations
information, so that it is available when fetching and creating the requested
objects.

The query can then be executed simply using::

	$results = $pSession->find(
        $query,
        'myEvent'
    );

This call returns only the requested objects of myEvent, behaving like the
original  ezcPersistentSession->find() method. The related objects will be kept
in memory and will be returned by the getRelatedObjects() method, if an object
of the result set is submitted to it.

.. note::
   This functionality can either be implemented on its own or be integrated
   with the identity map functionality, which also has the relation caching
   facilities.

-----------
Open issues
-----------

- PersistentObject allows multiple relations between the same PHP classes (see
  design 1.4). This leads to problems in the definition of the $relations array
  provided to the createFindQuery() method. It needs to be figured out how this
  information can be encoded there.

- It makes sense to use a decorated select query object to avoid the need for
  users to submit the $relations array twice: Once to the createFindQuery()
  method and once to the find() method. In ezcPersistentSession, it is
  currently required to submit the class name twice, which is redundant anyway.
  An idea would be to provide a generally decorated ezcQuerySelect class for
  PersistentObject, which would also orphan this redundant submission.

- Basically, this should be integrated with the ezcPersistentIdentitySession,
  because the related objects can then simply be store in the relation cache
  and be retrieved using getRelatedObjects() as usual. This requires only very
  few code changes for migrating users (just adding the fetches in a central
  place).

..
   Local Variables:
   mode: rst
   fill-column: 79
   End:
   vim: et syn=rst tw=79
