eZ component: PersistentObject, Design, 1.5
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:Author:   Tobias Schlitt
:Revision: $Rev$
:Date:     $Date$
:Status:   Draft

.. contents::

=====
Scope
=====

The scope of this document is to describe the proposed enhancements for the
PersistentObject component version 1.5.

The general goal for this version is to implement various features
described by these issues in our issue tracker:

- #11831: isRelated() Method.
- #12473: Identity map for PersistentObject.
- #13073: Sub-select support for PersistentObject.
- #13074: Fetching related objects through joins.
- #13170: Support for custom relation implementations.

Each of the issues and their proposed solutions are explained in a separate
chapter in this document. Some issues relate to each other, which is also
explained in the issue descriptions

---------------------------------
Identity map for PersistentObject
---------------------------------

The Identity Map pattern is described by Martin Fowler in his book Patterns of
Enterprise Application Architecture. The purpose of this pattern is to avoid
that 2 or more objects representing the same database row reside in memory. The
problems here are:

a) Duplicate memory consumption
b) Potential inconsistencies between different copies of the same object.

To avoid this, the data manipulation mechanisms must take care of not
delivering duplicate instances of the same data. Beside that, it can cache
certain queries as long as manipulations are reflected properly. The data
manipulation mechanisms in our case are realized in the ezcPersistentSession
and related (internal) handler classes.

Requirements
============

The implementation of this feature must try to take care that no object that is
loaded once from the database exists in a 2nd copy in the same request. This
means, the following operations are affected in the described way:

- load()

  Whenever an object is to be loaded, a lookup must take place, if this object
  has already been loaded. If this is the case, the loaded version should be
  returned. It must be evaluated if there is need to switch this lookup of in
  certain cases. However, usually the refresh() method should be used on the
  existing object in that case.

- loadIfExists()

  This method must check for an existing object instance like load() does.
  However, since it returns null if it does not, this result could also be
  cached or be re-evaluated as long as no object has been loaded successfully.

- loadIntoObject()

  This method should indicate an error, if an already loaded object is to be
  stored into another instance. In case the correct instance is given to the
  method, no changes are necessary. If a different object is given to load data
  into, 2 cases can occur:

  a) the object already has (stored) data. In this case an error must be
     indicated, since most probably there is no way to replace all of its
     instances with a clone in the cache mappings.
  b) the object has data, which has not been stored, yet. In this case, the
     data can be overwritten, as requested by the user.

- refresh()

  In this method, the object data can safely be refresh, since the instance
  should be the one already in the mapping cache. After all, a re-check should
  occur. If another instance exists in the cache, an error must be raised. If
  the object is not cached at all, it must be added.

- find()

  Inside this method, first it should be checked if the same find query was
  already performed earlier. In this case, a cached result set can be returned.
  There should be a switch to switch of this behavior, to make a new find to
  check for new objects. For a new query, the returned results must be checked
  element by element. Already loaded elements must be replaced with their
  cached version, newly loaded objects must be cached.

- findIterator()

  The iterator class, which is responsible for the retrieval of the data, must
  take care to realize the same behavior as find() does, here.

- getRelatedObjects()

  This method needs to check a cache first, if related object with the given
  criteria have already been loaded. If this is the case, they can safely be
  returned. It should be possible to switch off this behavior to reload related
  objects. If no objects are found, yet, the method must react as find() does,
  including the query cached objects.

- getRelatedObject()

  Same as getRelatedObjects().

- save()

  Whenever a new object is saved, it should be stored in the cache for later
  retrieval.

- saveOrUpdate()

  Same as save().

- addRelatedObject()

  If this method is called, the newly added related object should be added to
  the cache that is looked up by getRelatedObjects().

- delete()

  This method must take care to remove all references to the given object from
  the caches. This can lead to problems, if multiple caches need to be checked.

- removeRelatedObject()

  In this method, the relation cache needs to be updated in the opposite
  direction of addRelatedObject().


- \*FromQuery()

  This class of methods cannot be supported by the Identity Map, since it is
  not possible to determine the affected objects from the query, automatically.
  This would lead to heavy inconsistencies.

- create*Query()

  Corresponding to \*FromQuery() method, these methods cannot be supported,
  since the \*FromQuery() methods would be needed here, too. An exception is
  the createRelationFindQuery() and createFindQuery() method.


Design
======

The Identity Map support should be optional to not break BC and keep
flexibility. Therefore, a new class named ezcPersistentIdentityMapSession is
implemented. This extends the current implementation ezcPersistentSession to
make instanceof checks still work. All of the methods will be overwritten and
new handler classes, extending the existing ones will be implemented to reflect
the actual additions. The methods that are not supported by the new class will
be declared private and throw an exception is used externally.

The class design will work as follows:

ezcPersistenIdentitySession
---------------------------

This main class will be used exactly like its parent ezcPersistentSession and
realizes the desired functionality completely transparent to the user. This
allows users to transparently replace the old version and wise versa.

The central point of the class is an instance property $identityMap, that is
used as the session cache. All method calls that are affected as described in
the requirements will utilized this one to grab cached objects and to reflect
their changes.

The $identityMap property will contain an instance of ezcPersistentIdentityMap,
which is responsible to handle the actual caching process. Users do not have
direct access to this map. The following methods will be implemented on
ezcPersistentIdentityMapSession to allow direct manipulation of the identity
map:

- resetIdentityMap()

  This method cleans out the whole identity map completely. This might be
  dangerous since already loaded objects are not recorded anymore and therefore
  duplicates might occur again.

- resetIndentityQueryMap()

  This method just affects the query cache (see `ezcPersistentIdenityMap`_) and
  cleans it out completely. There is no risk in doing this, since objects are
  still recorded any only queries are affected.

The following methods will be marked as private and throw an exception if
publicly called:

- createUpdateQuery()
- updateFromQuery()
- createDeleteQuery()
- deleteFromQuery()

The rest of the methods either stays as it is or is slightly enhanced by an
optional parameter. The real enhancements will be implemented in the
ezcPersistentIdenityMap, which is utilized by extended session handlers as
described further below.

ezcPersistentIdenitySessionOptions
----------------------------------

The new ezcPersistentIdentitySession can be configured to switch on and off
certain features. The options are:

$relationCache = true;
  Switching this to false makes all relation query be executed and no result
  sets for relations be cached.
$refetchRelations = false;
  Setting this to true overwrites the $refetch parameter for
  getRelatedObjects() globally, so that relation queries are always executed
  but the results are still put into the cache.
$queryCache = false;
  Switching this on will enable the query cache for find queries and relatio
  queries.
$refetchQueries = false;
  If this option is enabled, queries are still cached, but are executed
  everytime to refetch the cache.

ezcPersistentIdentityMap
------------------------

This class is the internal heart of the identity map enhancement. It handles
all caching and mapping activities globally for a session.

Functionality
^^^^^^^^^^^^^

The following 3 areas of identity mapping will be handled:

1. The identity mapping itself.

   In this cache, each persistent object that is available in the session is
   recorded once. The mapping is::

        array(
            <class_name> => array(
                <id_value> => <object>,
                <id_value> => <object>,
                <id_value> => <object>,
                // ...
            ),
            // ...
        )

   An object is added to this cache map whenever it is loaded from the database
   (no matter in which way) or if it is stored. Operations which load objects
   from the database commonly check this map after the load occurred. If the
   loaded object already exists in the session, the newly loaded instance is
   discarded again and replaced by the existing one.

2. The relation mapping.

   The getRelatedObject[s]() methods are highly essential and also most
   performance hungry, if related objects need to be fetched for a large number
   of objects. To avoid this being performed multiple times in a request,
   results of calls to these methods should be cached dedicatedly. Whenever a
   set of related objects is retrieved, the following data structure will be
   updated::

        array(
            <source_class> => array(
                <source_id> => array(
                    <related_class> => array(
                        <related_id> => <related_object>,
                        <related_id> => <related_object>,
                        <related_id> => <related_object>,
                        // ...
                    ),
                    // ...
                ),
                // ...
            ),
            //...
        )

    Once again the same request is submitted to getRelatedObject[s](), the
    cached results will be returned. Since this behavior can be memory
    consuming if many of the loaded objects are discarded by the user directly
    after being loaded, it is be possible to disable this cache globally.  In
    addition, the refreshing of a set of objects will easily be possible, to
    update the cached results on request.

3. Query cache

   This 3rd, optional, cache map stores assignments of objects to search
   queries. This way, a duplicate performing of a custom query can completely be
   avoided. Whenever a query is performed through the persistent session, the
   result set of this query is cached in the following data structure::

        array(
            <query> => array(
                <object>,
                <object>,
                <object>,
                // ...
            ),
            // ...
        )

   This behavior will only be configurable globally, since not all query
   creations can directly be influenced by the user. Two switches are
   responsible for this: One to switch of the behavior in general, the second
   one to enable the regeneration of this cache globally. If the latter one is
   switched on, queries are still cached, but each query is executed instead of
   checking the cache for previous execution results.

Interface
^^^^^^^^^

The following methods will be provided by the map:

- recordObject( object $object )

  Adds a new object to the real identity map. The object will be replaced, if
  it has already been recorded earlier.

- getObject( string $class, mixed $id )

  Returns the object recorded for $class, identified by $id. If such object is
  not available, null is returned.

- recordRelatedObjects( object $sourceObject, array(object) $relatedObjects )

  Records the set of $relatedObjects to belong to $object. $relatedObjects
  must all be of the same type. The array may also contain objects that have
  already been recorded. These are then replaced.

- addRelatedObject( object $sourceObject, object $relatedObject )

  Appends a related object to an existing recorded relation. Used in
  ezcPersistentIdentitySession->addRelatedObject().

- removeRelatedObject( object $sourceObject, object $relatedObject )

  Removes a related object from the relation cache. Used in
  ezcPersistentIdentitySession->removeRelatedObject().

- getRelatedObjects( object $sourceObject, string $class )

  Returns an array of objects of type $class related to $sourceObject. This can
  also be an empty array, if the last lookup in the database resulted in such.
  In case no related objects have been recorded, yet, null is returned.

- resetRelatedObjects( object $sourceObject, string $class = null )

  This method clears the recorded objects of a type $class related to
  $sourceObject. This method should be used to re-initialize the mapping before
  a re-fetch takes place.

- recordQueryResult( ezcQuerySelect $query, array(object) $objects )

  Records the given set of objects to be the result of the given query. If
  already results exist, the complete result array will be overwritten.

- getQueryResult( ezcQuerySelect $query )

  Returns an array of objects that resulted from the given $query. This might
  also be an empty array, if the query returned an empty result set. If no
  results have been recorded for the given query, yet, null is returned.

- resetObjectMap()

  Resets the object map. Attention, dangerous!

- resetRelationMap()

  Resets the relation map. Attention, dangerous!

- resetQueryMap()

  Resets the query map.

- reset()

  Calls all 3 methods above.

ezcPersistentIdentityLoadHandler
--------------------------------

The following methods of the load handler will be enhanced as follows:

load( string $class, mixed $id )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In case the requested object is found in the identity map, it will be returned
from there. Otherwise it will be loaded and recorded. loadIfExists() will react
the same way.

loadIntoObject( object $object, mixed $id )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In case the given $object already is a loaded instance of an object, an
exception will be thrown. If the desired object with the $id was already
recorded in the identity map, an exception is thrown, too, since the operation
would result in a copy. Otherwise the load is performed as desired and the
resulting object instance is returned.

find( ezcQuerySelect $query, string $class, bool $refetch = false )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The find method is enhanced by a new 3rd parameter. If $fetch is false, first
the identity map will be asked for a cached result of the given query, if query
caching is enabled globally. If both requirements are fulfilled, the cached
query result will be returned. Otherwise the query will be performed and the
query result will be recorded, if query caching is globally switched on. Each
object returned by the query is checked in the identity map. If an instance of
one object already exists, this is replaced into the resulting array. If not,
the newly created instance is recorded.

findIterator( ezcQuerySelect $query, string $class )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method does not support query caching, because of 3 reasons: 1. the
results of the received query might not be processed at all. 2. another
implementation of the find iterator would be necessary to handle iteration over
cached results. 3. it might happen that the identity map is reset during
iteration, which would result in completely inconsistent results.

However, the method will return an extended version of the current
ezcPersistentFindIterator. This object will check before an object is returned,
if it is already recorded in the map. If it is, the recorded instance will be
returned. Otherwise the new instance will be recorded and returned.

getRelatedObjects( object $object, $relatedClass, $relationName = null, $refetch = false )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method is enhanced by the $refetch as the find() method is. If relation
caching is turned on globally and $refetch is false, the identity map is
requested for a cached result. In case this is found it is returned. Otherwise
the relation search is performed. Since the find() method is involved here, the
objects are already checked for their identity. If relation caching is globally
turned on, the result set is cached.


getRelatedObject( object $object, $relatedClass, $relationName = null, $refetch = false )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Same as above.

ezcPersistentIdentitySaveHandler
--------------------------------

The save handler methods will be enhanced as follows.

save( object $object )
^^^^^^^^^^^^^^^^^^^^^^

Whenever a new object was saved successfully, it is recorded in the identity
map.

saveOrUpdate( object $object )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method reacts the same as save() if the operation was not an update.

addRelatedObject( object $sourceObject, object $relatedObject )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If relation caching is globally switched on, the first check this method
performs is, if another object was previously related to this one and the new
$relatedObject replaces this relation. In this case, the old relation (if
recorded) is removed. After that, the new relation is recorded.

.. note::
   It should be discussed if it is feasible to perform the save() operation
   after a newly established relation automatically here, since otherwise
   inconsistencies might occur with the mapping cache. ezcPersistentSession
   does not do this, to avoid multiple UPDATE queries. Maybe a global switch in
   ezcPersistentSession to activate this overall might be sensible?

delete( object $object )
^^^^^^^^^^^^^^^^^^^^^^^^

This method must remove all references to the object from all mapping caches
before actually deleting the object itself from the DB. This is the most time
consuming work, since multiple array_search()/isset() calls might be necessary
in the following places:

- Query cache
- Relation cache

These only occur if the affected cache map is globally active. Performance
should be a major concern while writing this code.

.. note::
   The delete() operation also removes all relations and, if cascading is used,
   also removes related objects. Therefore the operation might even run longer.

removeRelatedObject( object $sourceObject, object $relatedObject, string $relationName = null )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If relation caching is globally turned on, the relation must be removed from
the cache before it is actually removed.

.. note::
   It should be discussed if it is feasible to perform the save() operation
   after a newly established relation automatically here, since otherwise
   inconsistencies might occur with the mapping cache. ezcPersistentSession
   does not do this, to avoid multiple UPDATE queries. Maybe a global switch in
   ezcPersistentSession to activate this overall might be sensible?

Open questions
==============

- Making the identity map a decorator to ezcPersistentSession would design wise
  be a nicer solution, but also has some flaws:
  - No transparent replacement of current $session objects possible, due to
    instanceof checks. Maybe introduce a common interface (would also allow
    different implementations of ezcPersistentSession in future)?
  - It would make sense to allow the identity mapping session to acces certain
    protected functionality (creation of queries, execution, ...). This could
    be solved by making the affected methods public and documenting them as
    protected.
- Do we need an option to explicitly reload (load()) an object? refresh() on
  the existing version is more logical.
- loadIfExists() can return null. Should this result be cached or should the
  method try to load again if no object has been loaded successfully, yet?
- The updates to perform in the delete() method can become quite time consuming
  if all caching facilities are switched on.
- A nice idea would be to enable the replacement of ezcPersistentIdentityMap
  with a custom implementation. For example it could make sense to offer a
  PersistentObjectCacheTiein to have the identity map cache objects to disc
  (request by BD).

--------------------------------------
Fetching related objects through joins
--------------------------------------

Relation management with Persistent Objects is very convenient and powerful.
However, it suffers from one of the common consequences of such methods: the
amount of SQL queries you end up executing.

Since using relations is easy, you will easily end up running dozens or hundreds
of SQL queries, especially when using the templates component::

	{$event->location->name}

Very convenient, but this will run at least one extra query here; if you do this
when listing, let's say events, you will execute one extra query for each event
you display the location for. If you also display the event's responsible name,
it's another query. If you show 10 events, you execute 21 queries, and this is
not acceptable.

Design
======

Since ezcPersistentObject allows us to define relations between persistent
classes, we have everything we need to fetch all desired objects in one
operation. To allow the user to limit the fetched objects effectively, the
createFindQuery method will be enhanced to create queries that fetch objectes
and their relatives. ::

    ezcQuerySelect createFindQuery( string $class, array $relations = null )

The $relations parameter contains an array structure which represents the
relation tree to fetch. The structure of this array will look as follows::

    array(
        'myLocation' => true,
        'myResponsible' => array(
            'myAddress' => true,
            'myCompany' => true,
        ),
    )

The keys of the array structure represent persistent class names. A key might
either be assigned to the value true or to another array of relatives to fetch.
True means "fetch the desired relatives, but no further ones in this
direction". An array as the value describes to fetch further relatives for the
relative.

In the example above objects of 2 different classes will be fetched for the
source objects originally fetched by the find query: myLocation and
myResponsible. For the objects fetched fore the myResponsible class further
relatives will be fetched in addition: myAddress and myCompany.

The query object returned by the createFindQuery() method already implements
all joins necessary to fetch the desired objects. Beside that, is has aliases
registered for all requested relatives as well as for the source class. The
source class aliases are registered without any prefix, as known from the
original behavior of createFindQuery(). For the relatives, the aliases will be
prefixed by the class hierarchy indicated by the relation array. This allows
the user to define additional WHERE and ORDER BY statements on the SELECT
query.

For example, if the myLocation class defines a persistent attribute $city, an
alias myLocation_city will be available. The myAddress->$zip property will be
available through the alias myRepsonsible_myAddress_zip. The prefixing with all
ascending classes is necessary to avoid conflicts if relations to one class
should be resolved in different places.

The query object returned by createFindQuery() with the additional $relations
parameter will not be an instanca of ezcQuerySelect directly, but a decorated
version. This allows the method to annotate the query with the $relations
information, so that it is available when fetching and creating the requested
objects.

The query can then be executed simply using::

	$results = $pSession->find(
        $query,
        'myEvent'
    );

This call returns only the requested objects of myEvent, behaving like the
original  ezcPersistentSession->find() method, The related objects will be kept
in memory and will be returned by the getRelatedObjects() method, if an object
of the result set is submitted to it.

.. note::
   This functionality can either be implemented on its own or be integrated
   with the identity map fucntionality, which also has the relation caching
   facilities.

Open issues
===========

- PersistentObject allows multiple relations between the same PHP classes (see
  design 1.4). This leads to problems in the definition of the $relations array
  provided to the createFindQuery() method. It needs to be figured out how this
  information can be encoded there.
- It makes sense to use a decorated select query object to avoid the need for
  users to submit the $relations array twice: Once to the createFindQuery()
  method and once to the find() method. In ezcPersistentSession, it is
  currently required to submit the class name twice, which is redundant anway.
  An idea would be to provide a generally decorated ezcQuerySelect class for
  PersistentObject, which would also orphan this redundant submission.
- Basically, this should be integrated with the ezcPersistentIdentitySession,
  because the related objects can then simply be store in the relation cache
  and be retrieved using getRelatedObjects() as usual. This requires only very
  few code changes for migrating users (just adding the fetches in a central
  place).

..
   Local Variables:
   mode: rst
   fill-column: 79
   End:
   vim: et syn=rst tw=79
